---
title: A practical guide to geospatial interpolation with R
author: ~
date: '2020-05-21'
slug: spatial_interpolation
categories: []
tags: []
subtitle: ''
summary: ''
authors: []
lastmod: '2020-05-21T18:09:20+02:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
draft: true
---



<p>One of the most exciting things you can to with R is geospatial interpolation. This means that you have some kind of information (e.g. measurements of, say, soil temperature) for a limited number of locations and then you apply a mathematical model that will provide you with an educated guess of what your result might look like, if you would have measured at every possible location. The practical advantage is clear. Sampling is expensive and therefore always limited. This is especially true in the geosciences, where sampling might require hundreds of thousands of Euros for drilling deep holes to the formation of your interest.</p>
<p>Doing your geospatial interpolation in R is a great opportunity. Many software tools often associated with that task are commercial products that can become fairly expensive, so it is pretty common that if one finishes university or changes a job position, all the work spend on learning that tool is rendered void. R on the other hand is always free and offers a wide range of algorithms of all kinds of flavours. An additional bonus is the seamless integration with the powerful data transformation and visualization capabilities of the language.</p>
<p>A problem when using R (especially at the beginning) is, that the user interface for the application of different algorithms on the many available data structures varies wildly. Although improvements clearly have been made in the recent years, there is little standardization and every package author basically comes up with their own philosophy on how to handle input/output.</p>
<p>As a consequence, starting with geospatial interpolation in R can be frustrating. Of course you can (and will have to) dig through the documentation of the various packages, but as interpolation models are a fairly advanced topic of statistics, those tend to be heavy on technical slang.</p>
<p>There are a couple of good blog posts (see <a href="https://rpubs.com/nabilabd/118172">here</a>, <a href="https://rspatial.org/raster/analysis/4-interpolation.html">here</a> and <a href="https://fishandwhistle.net/post/2019/bathymetry-lake-volume-estimation-using-r/">here</a>) on geospatial interpolation, but they either focus on dealing with specific package interfaces or are again written for an audience that is already well versed in the world of spatial data.</p>
<p>When I started to learn about geospatial interpolation with R a couple of years ago, I found it difficult to get up to speed with real world data. Most use cases I found focuses on pre-treated datasets whose conditions I could not sensibly reproduce with my own data or made steps that seemed outright incomprehensible at that time. So I feel like there is a documentation gap for a practical guide of the very basics of geospatial interpolation: how do I get from having a bunch of field observations to a regular raster of interpolated values that I can plot on a nice little map? I am going to present you here with a minimalistic workflow designed to step-by-step explain the principles behind the necessary operations that all approaches for geospatial interpolation with R have in common. That way I hope your entrance into this fascinating world will be more pleasent than mine was.</p>
<p>There are four steps to Geospatial interpolation
0. Have some data
1. Create a grid template
2. Fit a model
3. Interpolate!</p>
<p>So let’s start!</p>
<p># Step 0: Have some data</p>
<pre class="r"><code>library(tidyverse) # data wrangling and plotting
library(sf) # processing spatial vector data
library(raster) # processing spatial raster data. !!!overwrites dplyr::select!!!


# Download the data for this tutorial from Github
# Data is provided by the senate of the city of Berlin under:
# dl-de/by-2-0 Umweltatlas Berlin / Grundwassergüte Ammonium (Umweltatlas)
# for more details see: http://www.stadtentwicklung.berlin.de/umwelt/umweltatlas/ia204.htm

pts_NH4 &lt;- readr::read_csv(
  &quot;https://raw.githubusercontent.com/Ignimbrit/exchange/master/data/2020/Ammonium_Hoppegarten.csv&quot;,
  col_types = cols(NH4 = col_double(), 
                   X = col_double(), Y = col_double(), 
                   fid = col_character(), licence = col_character())
  ) %&gt;% 
  dplyr::select(X, Y, NH4)

print(pts_NH4)</code></pre>
<pre><code>## # A tibble: 64 x 3
##          X        Y   NH4
##      &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;
##  1 406521. 5814334.   2.3
##  2 409320. 5814598.  20.2
##  3 410322. 5814606.   0.3
##  4 408804. 5814825.   4.1
##  5 409049. 5814830.   2.5
##  6 408701. 5814896.  11.3
##  7 408843. 5814898.  16.1
##  8 409022. 5814928.   3  
##  9 408865. 5814943.  12  
## 10 408729. 5814949.  24.4
## # ... with 54 more rows</code></pre>
<p>In the chunk above we already solved Step 0: Have some data! For this tutorial I compiled a little demonstration dataset (see comments for the source) that you can download from github to follow my steps. The data comes from a csv that contains 64 measurements of <a href="https://en.wikipedia.org/wiki/Ammonium">Ammonium</a> (chemical formula NH4+) in groundwater from a former septic drain field (“Rieselfeld”) at a place called Hoppegarten at the outer rim of Berlin. Ammonium in groundwater can be a problem, so it would be good to know exactly how big our problem is, which can hardly be assessed by a couple of randomly scattered points per se.</p>
<pre class="r"><code>point_plot &lt;- ggplot(
  data = pts_NH4,
  mapping = aes(x = X, y = Y, color = NH4)) +
  geom_point(size = 3) +
  scale_color_gradientn(colors = c(&quot;blue&quot;, &quot;yellow&quot;, &quot;red&quot;))

point_plot</code></pre>
<p><img src="/post/2020-05-21-guide_to_spatial_interp/index_files/figure-html/pts_plot-1.png" width="672" /></p>
<p>We can see from plotting the points alone that there seems to be som spatial dependency on the ammonium concentration. Samples with high concentration seem to be sitting mostly at the center of the plot. This is all we need: a coordinate pair (in this context sometimes referred to as the independent variables) and an associated continuous variable (the corresponding dependent variable). If there is a spatial pattern behind the values of the continuous variable (so that it really is depending on the coordinates specifying its position), geospatial interpolation can work.</p>
<p># Step 1: Create a grid template</p>
<p>This is one of the less intuitive steps but a very important one nonetheless. You need to specify were you would like to interpolate (aka generate new information), before you actually have that new information. When learning about geospatial interpolation with R in the first place, this was the step used to bother me the most. After all: how am I supposed to know where I would like my information, if I do not actually have any for now?</p>
<p>I will not dive any further into the why and hows here. For now just accept that we need a template to later fill it with interpolated values, and that creating this template is super easy, so that you should not worry about it. There are a couple of catches, but we will discuss those as we encounter then. Let’s start with a very basic approach to grid template making.</p>
<p>## Option a) The simple approach</p>
<pre class="r"><code># First let&#39;s define a bounding Box, a rectangle that contains all our data
# points. There are many ways to do this but I am keeping it as simple as
# possible on purpose here
bbox &lt;- c(
  &quot;xmin&quot; = min(pts_NH4$X),
  &quot;ymin&quot; = min(pts_NH4$Y),
  &quot;xmax&quot; = max(pts_NH4$X),
  &quot;ymax&quot; = max(pts_NH4$Y)
)

grd_template &lt;- expand.grid(
  X = seq(from = bbox[&quot;xmin&quot;], to = bbox[&quot;xmax&quot;], by = 20),
  Y = seq(from = bbox[&quot;ymin&quot;], to = bbox[&quot;ymax&quot;], by = 20) # 20 m resolution
)

grid_plot &lt;- ggplot() +
  geom_point(data = grd_template, aes(x = X, y = Y), size = 0.01) +
  geom_point(data = pts_NH4,
  mapping = aes(x = X, y = Y, color = NH4), size = 3) +
  scale_color_gradientn(colors = c(&quot;blue&quot;, &quot;yellow&quot;, &quot;red&quot;)) +
  coord_cartesian( #zooming in so we can actually see something
    xlim = c(408000, 409000), ylim = c(5815000, 5816000))

grid_plot</code></pre>
<p><img src="/post/2020-05-21-guide_to_spatial_interp/index_files/figure-html/simple_gridmaking-1.png" width="672" /></p>
<p>So this is the most simple approach on making a grid_template I could think of. And when I simple I mean that in an absolute positive way. No dependencies, no domain specific knowledge. It has the advantage of needing no other libraries and producing a <code>data.frame</code> which is easy to handle.</p>
<p>## Option b) the classical approach</p>
<p>Using <code>base::expand.grid</code> is not necessarily the best way to build your grid template. Another popular way is to use <code>sf::st_make_grid</code></p>
<pre class="r"><code>sf_NH4 &lt;- st_as_sf(pts_NH4, coords = c(&quot;X&quot;, &quot;Y&quot;), crs = 25833)
alt_grd_template_sf &lt;- st_make_grid(
  sf_NH4, cellsize = c(20, 20), what = &quot;centers&quot;) %&gt;%
  cbind(., st_coordinates(.))</code></pre>
<p>Those commands will create a fairly similar grid to the one we made above, but there are some differences.</p>
<ul>
<li>The <code>alt_grd_template_sf</code> does actually contain all sample points. If you’ve been following my steps closely, you might have noticed, that I made no effort ensuring that when creating <code>grd_template</code> in my call to <code>expand.grid</code></li>
<li><code>alt_grd_template_sf</code> was created using functions from the <code>sf</code>package and the object itself is not a simple <code>data.frame</code> but comes in a data structure profided by that package (a <code>sfc</code>, or simple feature coloumn, to be specific).</li>
</ul>
<p>Working with the data structures from the <code>sf</code> package is great. They are specifically build to handle spatial vector data and many interpolation algorithms that are out their are explicitly tailored towards accepting them or the closely related structures from the “older-sister-package” <code>sp</code>.</p>
<p># Step 1b: Rasterizing your grid template</p>
<p>I warned you that this tutorial would have to be a bit convoluted. We have our grid template now and it contains all the information we need, but not in every case in the data structure we need it to be in. Regardless whether you prefer <code>base::expand.grid</code> or <code>sf::st_make_grid</code>, what you get in return is essentially a table of point coordinates.</p>
<p>For some interpolation algorithms this is just fine as they work well with data.frames. Others don’t. Usually there are ways to make it work but often enough things will get messy. As we want to look at a couple of different interpolation methods from different packages with vastly different interfaces and expectations, we will create a copy of our grid template in a dirrefent data structure to make our life a little easier.</p>
<pre class="r"><code>grd_template_raster &lt;- grd_template %&gt;% 
  dplyr::mutate(Z = 0) %&gt;% 
  raster::rasterFromXYZ( # {raster} expects a PROJ.4 string, see https://epsg.io/25833
    crs = &quot;+proj=utm +zone=33 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs&quot;)</code></pre>
<pre class="r"><code>library(tidyverse)
library(mapview)
library(sf)
library(raster)

pts_NH4 &lt;- readr::read_csv(
  &quot;https://raw.githubusercontent.com/Ignimbrit/exchange/master/data/2020/Ammonium_Hoppegarten.csv&quot;,
  col_types = cols(NH4 = col_double(), 
                   X = col_double(), Y = col_double(), 
                   fid = col_character(), licence = col_character())
  ) %&gt;% 
  select(X, Y, NH4)

sf_NH4 &lt;- st_as_sf(pts_NH4, coords = c(&quot;X&quot;, &quot;Y&quot;), crs = 25833)
mapview(sf_NH4, map.types = &quot;OpenTopoMap&quot;)

bbox &lt;- c(
  &quot;xmin&quot; = min(pts_NH4$X),
  &quot;ymin&quot; = min(pts_NH4$Y),
  &quot;xmax&quot; = max(pts_NH4$X),
  &quot;ymax&quot; = max(pts_NH4$Y)
)

grd_template &lt;- expand.grid(
  X = seq(from = bbox[&quot;xmin&quot;], to = bbox[&quot;xmax&quot;], by = 20),
  Y = seq(from = bbox[&quot;ymin&quot;], to = bbox[&quot;ymax&quot;], by = 20) # 20 m resolution
)

raster_template &lt;- grd_template %&gt;% 
  mutate(Z = 0) %&gt;% 
  rasterFromXYZ( # {raster} expects a PROJ.4 string, see https://epsg.io/25833
    crs = &quot;+proj=utm +zone=33 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs&quot;)

#########
library(fields)
m &lt;- fields::Tps(x = as.matrix(select(pts_NH4, X, Y)), Y = pts_NH4$NH4, miles = FALSE)
r &lt;- interpolate(raster_template, m)

test &lt;- st_as_sf(pts_NH4, coords = c(&quot;X&quot;, &quot;Y&quot;), crs = 25833)
test2 &lt;- st_as_sf(mutate(grd_template, id = seq(1, nrow(grd_template))), coords = c(&quot;X&quot;, &quot;Y&quot;), crs = 25833)</code></pre>
